diff --git a/src/main.rs b/src/main.rs
index 65cf26d..5c71aaf 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,44 +1,50 @@
 mod balances;
 mod system;
 
 type AccountId = &'static str;
 type Balance = u128;
 type BlockNumber = u32;
 type Nonce = u32;
 
+/*
+	TODO:
+	Implement the `system::Config` trait you created on your `Runtime`.
+	Use `Self` to satisfy the generic parameter required for `system::Pallet`.
+*/
+
 // This is our main Runtime.
 // It accumulates all of the different pallets we want to use.
 #[derive(Debug)]
 pub struct Runtime {
 	system: system::Pallet<AccountId, BlockNumber, Nonce>,
 	balances: balances::Pallet<AccountId, Balance>,
 }
 
 impl Runtime {
 	// Create a new instance of the main Runtime, by creating a new instance of each pallet.
 	fn new() -> Self {
 		Self { system: system::Pallet::new(), balances: balances::Pallet::new() }
 	}
 }
 
 fn main() {
 	let mut runtime = Runtime::new();
 	runtime.balances.set_balance(&"alice", 100);
 
 	// start emulating a block
 	runtime.system.inc_block_number();
 	assert_eq!(runtime.system.block_number(), 1);
 
 	// first transaction
 	runtime.system.inc_nonce(&"alice");
 	let _res = runtime.balances.transfer(&"alice", &"bob", 30).map_err(|e| eprintln!("{}", e));
 
 	// second transaction
 	runtime.system.inc_nonce(&"alice");
 	let _res = runtime
 		.balances
 		.transfer(&"alice", &"charlie", 20)
 		.map_err(|e| eprintln!("{}", e));
 
 	println!("{:#?}", runtime);
 }
diff --git a/src/system.rs b/src/system.rs
index dd26b67..0c93a86 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -1,58 +1,72 @@
 use core::ops::AddAssign;
 use num::traits::{One, Zero};
 use std::collections::BTreeMap;
 
+/*
+	TODO: Combine all generic types and their trait bounds into a single `pub trait Config`.
+	When you are done, your `Pallet` can simply be defined with `Pallet<T: Config>`.
+*/
+
 /// This is the System Pallet.
 /// It handles low level state needed for your blockchain.
 #[derive(Debug)]
 pub struct Pallet<AccountId, BlockNumber, Nonce> {
 	/// The current block number.
 	block_number: BlockNumber,
 	/// A map from an account to their nonce.
 	nonce: BTreeMap<AccountId, Nonce>,
 }
 
+/*
+	TODO: Update all of these functions to use your new configuration trait.
+*/
+
 impl<AccountId, BlockNumber, Nonce> Pallet<AccountId, BlockNumber, Nonce>
 where
 	AccountId: Ord,
 	BlockNumber: Zero + One + AddAssign + Copy,
 	Nonce: Zero + One + Copy,
 {
 	/// Create a new instance of the System Pallet.
 	pub fn new() -> Self {
 		Self { block_number: BlockNumber::zero(), nonce: BTreeMap::new() }
 	}
 
 	/// Get the current block number.
 	pub fn block_number(&self) -> BlockNumber {
 		self.block_number
 	}
 
 	// This function can be used to increment the block number.
 	// Increases the block number by one.
 	pub fn inc_block_number(&mut self) {
 		self.block_number += BlockNumber::one();
 	}
 
 	// Increment the nonce of an account. This helps us keep track of how many transactions each
 	// account has made.
 	pub fn inc_nonce(&mut self, who: AccountId) {
 		let nonce = *self.nonce.get(&who).unwrap_or(&Nonce::zero());
 		let new_nonce = nonce + Nonce::one();
 		self.nonce.insert(who, new_nonce);
 	}
 }
 
 #[cfg(test)]
 mod test {
+	/*
+		TODO: Create a `struct TestConfig`, and implement `super::Config` on it with concrete types.
+		Use this struct to instantiate your `Pallet`.
+	*/
+
 	#[test]
 	fn init_system() {
 		let mut system = super::Pallet::<&'static str, u32, u32>::new();
 		system.inc_block_number();
 		system.inc_nonce(&"alice");
 
 		assert_eq!(system.block_number(), 1);
 		assert_eq!(system.nonce.get(&"alice"), Some(&1));
 		assert_eq!(system.nonce.get(&"bob"), None);
 	}
 }
