diff --git a/src/main.rs b/src/main.rs
index 8a1c379..5cdbd53 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,47 +1,49 @@
 mod balances;
 mod system;
 
 // These are the concrete types we will use in our simple state machine.
 // Modules are configured for these types directly, and they satisfy all of our
 // trait requirements.
 mod types {
 	pub type AccountId = &'static str;
 	pub type Balance = u128;
+	/* TODO: Move your type definitions for `BlockNumber` and `Nonce` here. */
 }
 
 // This is our main Runtime.
 // It accumulates all of the different pallets we want to use.
 #[derive(Debug)]
 pub struct Runtime {
+	/* TODO: Use your type definitions for your new generic `system::Pallet`. */
 	system: system::Pallet,
 	balances: balances::Pallet<types::AccountId, types::Balance>,
 }
 
 impl Runtime {
 	// Create a new instance of the main Runtime, by creating a new instance of each pallet.
 	fn new() -> Self {
 		Self { system: system::Pallet::new(), balances: balances::Pallet::new() }
 	}
 }
 
 fn main() {
 	let mut runtime = Runtime::new();
 	runtime.balances.set_balance(&"alice", 100);
 
 	// start emulating a block
 	runtime.system.inc_block_number();
 	assert_eq!(runtime.system.block_number(), 1);
 
 	// first transaction
 	runtime.system.inc_nonce(&"alice");
 	let _res = runtime.balances.transfer(&"alice", &"bob", 30).map_err(|e| eprintln!("{}", e));
 
 	// second transaction
 	runtime.system.inc_nonce(&"alice");
 	let _res = runtime
 		.balances
 		.transfer(&"alice", &"charlie", 20)
 		.map_err(|e| eprintln!("{}", e));
 
 	println!("{:#?}", runtime);
 }
diff --git a/src/system.rs b/src/system.rs
index 4b0d0b2..617e199 100644
--- a/src/system.rs
+++ b/src/system.rs
@@ -1,55 +1,74 @@
 use std::collections::BTreeMap;
 
 type AccountId = &'static str;
 type BlockNumber = u32;
 type Nonce = u32;
 
+/*
+	TODO:
+	Update the `Pallet` struct to be generic over the `AccountId`, `BlockNumber`, and `Nonce` type.
+	You won't need the type definitions above after you are done.
+	Types will now be defined in `main.rs`. See the TODOs there.
+*/
+
 /// This is the System Pallet.
 /// It handles low level state needed for your blockchain.
 #[derive(Debug)]
 pub struct Pallet {
 	/// The current block number.
 	block_number: BlockNumber,
 	/// A map from an account to their nonce.
 	nonce: BTreeMap<AccountId, Nonce>,
 }
 
+/*
+	TODO:
+	The generic types need to satisfy certain traits in order to be used in the functions below.
+	See if you can figure them out yourself.
+
+	NOTE: You might need to adjust some of the functions below to satisfy the borrow checker.
+*/
+
 impl Pallet {
 	/// Create a new instance of the System Pallet.
 	pub fn new() -> Self {
 		Self { block_number: 0, nonce: BTreeMap::new() }
 	}
 
 	/// Get the current block number.
 	pub fn block_number(&self) -> BlockNumber {
 		self.block_number
 	}
 
 	// This function can be used to increment the block number.
 	// Increases the block number by one.
 	pub fn inc_block_number(&mut self) {
 		self.block_number += 1;
 	}
 
 	// Increment the nonce of an account. This helps us keep track of how many transactions each
 	// account has made.
 	pub fn inc_nonce(&mut self, who: AccountId) {
 		let nonce = *self.nonce.get(who).unwrap_or(&0);
 		let new_nonce = nonce + 1;
 		self.nonce.insert(who, new_nonce);
 	}
 }
 
 #[cfg(test)]
 mod test {
 	#[test]
 	fn init_system() {
+		/*
+			TODO:
+			When creating an instance of `Pallet`, you should explicitly define the types you use.
+		*/
 		let mut system = super::Pallet::new();
 		system.inc_block_number();
 		system.inc_nonce(&"alice");
 
 		assert_eq!(system.block_number(), 1);
 		assert_eq!(system.nonce.get(&"alice"), Some(&1));
 		assert_eq!(system.nonce.get(&"bob"), None);
 	}
 }
